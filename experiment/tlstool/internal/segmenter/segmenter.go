// Package segmenter contains code that splits TCP data in three
// segments as described by Kevin Boch in https://youtu.be/ksojSRFLbBM?t=1140.
package segmenter

import (
	"context"
	"net"
	"time"

	"github.com/ooni/probe-engine/netx"
)

// Dialer creates connections where we split TCP data in three
// segments as mentioned above. We optionally also delay writing
// each segment by a specific number of milliseconds.
type Dialer struct {
	netx.Dialer
	Delay int64
}

// DialContext implements netx.Dialer.DialContext.
func (d Dialer) DialContext(ctx context.Context, network, address string) (net.Conn, error) {
	conn, err := d.Dialer.DialContext(ctx, network, address)
	if err != nil {
		return nil, err
	}
	return Conn{Conn: conn, Delay: d.Delay}, nil
}

// Conn is the net.Conn generated by segmenter.Dialer.
//
// Caveat
//
// The connection will keep splitting segments forever. This behaviour
// is fine as long as we're just checking whether the TLS handshake works.
type Conn struct {
	net.Conn
	BeforeSecondWrite func() // for testing
	BeforeThirdWrite  func() // for testing
	Delay             int64
}

// Write implements net.Conn.Write.
func (c Conn) Write(b []byte) (int, error) {
	const (
		first  = 8
		second = 12
	)
	if len(b) > second {
		if _, err := c.Conn.Write(b[:first]); err != nil {
			return 0, err
		}
		<-time.After(time.Duration(c.Delay) * time.Millisecond)
		if c.BeforeSecondWrite != nil {
			c.BeforeSecondWrite()
		}
		if _, err := c.Conn.Write(b[first:second]); err != nil {
			return 0, err
		}
		<-time.After(time.Duration(c.Delay) * time.Millisecond)
		if c.BeforeThirdWrite != nil {
			c.BeforeThirdWrite()
		}
		if _, err := c.Conn.Write(b[second:]); err != nil {
			return 0, err
		}
		return len(b), nil
	}
	return c.Conn.Write(b)
}
