package oonimkall

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"math"
	"time"

	engine "github.com/ooni/probe-engine"
	"github.com/ooni/probe-engine/internal/runtimex"
	"github.com/ooni/probe-engine/model"
	"github.com/ooni/probe-engine/probeservices"
)

// SessionConfig contains configuration for a Session.
type SessionConfig struct {
	// AssetsDir is the mandatory directory where to store assets
	// required by a Session, e.g. MaxMind DB files.
	AssetsDir string

	// Logger is the optional logger that will receive all the
	// log messages generated by a Session. If this field is nil
	// then the session will not emit any log message.
	Logger Logger

	// SoftwareName is the mandatory name of the application
	// that is using the OONI Probe Engine.
	SoftwareName string

	// SoftwareVersion is the mandatory version of the application
	// that is using the OONI Probe Engine.
	SoftwareVersion string

	// StateDir is the mandatory directory where to store state
	// information required by a Session.
	StateDir string

	// TempDir is the mandatory directory where the Session shall
	// store temporary files. Among other tasks, Session.Close will
	// ensure that temporary files have been removed.
	TempDir string

	// Verbose is optional. If there is a non-null Logger and this
	// field is true, then the Logger will also receive Debug messages,
	// otherwise it will not receive such messages.
	Verbose bool
}

// Logger is the logger used by a Session. You should implement a class
// compatible with this interface in Java/ObjC and then save a reference
// to this instance in the SessionConfig object. All log messages that
// the Session will generate will be routed to this Logger.
type Logger interface {
	Debug(msg string)
	Info(msg string)
	Warn(msg string)
}

type loggerVerbose struct {
	Logger
}

func (slv loggerVerbose) Debugf(format string, v ...interface{}) {
	slv.Debug(fmt.Sprintf(format, v...))
}
func (slv loggerVerbose) Infof(format string, v ...interface{}) {
	slv.Info(fmt.Sprintf(format, v...))
}
func (slv loggerVerbose) Warnf(format string, v ...interface{}) {
	slv.Warn(fmt.Sprintf(format, v...))
}

type loggerNormal struct {
	Logger
}

func (sln loggerNormal) Debugf(format string, v ...interface{}) {
	// nothing
}
func (sln loggerNormal) Debug(msg string) {
	// nothing
}
func (sln loggerNormal) Infof(format string, v ...interface{}) {
	sln.Info(fmt.Sprintf(format, v...))
}
func (sln loggerNormal) Warnf(format string, v ...interface{}) {
	sln.Warn(fmt.Sprintf(format, v...))
}

type loggerQuiet struct{}

func (loggerQuiet) Debugf(format string, v ...interface{}) {
	// nothing
}
func (loggerQuiet) Debug(msg string) {
	// nothing
}
func (loggerQuiet) Infof(format string, v ...interface{}) {
	// nothing
}
func (loggerQuiet) Info(msg string) {
	// nothing
}
func (loggerQuiet) Warnf(format string, v ...interface{}) {
	// nothing
}
func (loggerQuiet) Warn(msg string) {
	// nothing
}

// NewLogger creates a new instance of model.Logger from the provided
// config. This factory function is not available to Java/ObjC because
// the returned type is not supported. This is intended: it does not
// make sense to use a model.Logger when not using Go.
func NewLogger(config *SessionConfig) model.Logger {
	if config == nil || config.Logger == nil {
		return loggerQuiet{}
	}
	if config.Verbose {
		return loggerVerbose{Logger: config.Logger}
	}
	return loggerNormal{Logger: config.Logger}
}

// The Context allows the programmer to interrupt long running operations
// and/or to add specific timeouts to such operations. Make sure you always
// call Close when you are done using a Context.
type Context struct {
	cancel  context.CancelFunc
	ctx     context.Context
	timeout int64
}

// NewContext creates a new Context.
func NewContext() *Context {
	ctx := new(Context)
	ctx.ctx, ctx.cancel = context.WithCancel(context.Background())
	return ctx
}

// MaxContextTimeout is the maximum timeout that you can set with
// the NewContextWithTimeout function. Any value greater than this
// value will be silently clamped down to such a value.
const MaxContextTimeout = int64(time.Duration(math.MaxInt64) / time.Second)

// NewContextWithTimeout creates a new Context where the operations using
// such a Context will fail after timeout seconds. If the timeout argument
// is zero or less, this constructor is equivalent to NewContext. Note that
// any value that is greater than MaxContextTimeout is clamped down to
// MaxContextTimeout to avoid overflow errors.
func NewContextWithTimeout(timeout int64) *Context {
	ctx := new(Context)
	if timeout > 0 {
		if timeout > MaxContextTimeout {
			timeout = MaxContextTimeout
		}
		ctx.ctx, ctx.cancel = context.WithTimeout(
			context.Background(), time.Duration(timeout)*time.Second,
		)
		ctx.timeout = timeout
	} else {
		ctx.ctx, ctx.cancel = context.WithCancel(context.Background())
	}
	return ctx
}

// Context returns the underlying context.Context. This method is not
// exported to Java/ObjC because the context.Context type is an interface
// containing some fields that cannot be represented in Java/ObjC.
//
// Because this method is not exported to Java/ObjC we will not bother
// with making sure that it behaves with a null pointer receiver.
func (ctx *Context) Context() context.Context {
	return ctx.ctx
}

// GetTimeout returns the timeout (in seconds) configured for the context. A
// negative or zero value implies there is no timeout.
func (ctx *Context) GetTimeout() (timeout int64) {
	if ctx != nil {
		timeout = ctx.timeout
	}
	return
}

// Cancel cancels any pending operation. This method is idempotent
// and only its first invocation has side effects. This method is
// thread safe; it might be called from any thread.
func (ctx *Context) Cancel() {
	if ctx != nil {
		ctx.cancel()
	}
}

// Close releases the resources allocated by the SessionContext. This
// method is idempotent; only its first invocation has side effects. It
// is also thread safe and might be called from any thread.
func (ctx *Context) Close() error {
	ctx.Cancel() // calling Cancel which handles nil gracefully
	return nil
}

// ErrNullPointer indicates that you passed to any API within the
// oonimkall package a null pointer. We generally don't bother with
// handling this error condition in Go or Java, but across the
// programming languages boundaries it is more critical to perform
// these checks. Specifically, the program will crash without any
// possibility of repair (i.e. panic) when Go receives a null pointer
// from Java. This will not be a great user experience.
var ErrNullPointer = errors.New("oonimkall: you passed me a null pointer")

// Session contains shared state for running experiments and/or other
// OONI related task (e.g. geolocation). Note that the Session isn't
// mean to be shared across thread. It is also not meant to be a long
// living object. The workflow is to create a Session, do the operations
// you need to do with it now, then call Session.Close. All of this is
// supposed to happen within the same Java thread. If you need to cancel
// any operation from other threads, please use a Context instead.
type Session struct {
	s *engine.Session
}

// NewSession creates a new session. You should use a session for running
// related operation in a relatively short time frame. You should not create
// a single session and keep it all alive for the whole app lifecyle, since
// the Session code is not specifically designed for this use case.
func NewSession(config *SessionConfig) (*Session, error) {
	if config == nil {
		return nil, ErrNullPointer
	}
	kvstore, err := engine.NewFileSystemKVStore(config.StateDir)
	if err != nil {
		return nil, err
	}
	engineConfig := engine.SessionConfig{
		AssetsDir:       config.AssetsDir,
		KVStore:         kvstore,
		Logger:          NewLogger(config),
		SoftwareName:    config.SoftwareName,
		SoftwareVersion: config.SoftwareVersion,
		TempDir:         config.TempDir,
	}
	sess, err := engine.NewSession(engineConfig)
	if err != nil {
		return nil, err
	}
	return &Session{s: sess}, nil
}

// Close closes the resources used by a Session. Specifically, we close
// any still open connection and cleanup temporary storage.
//
// Bug
//
// This method is not idempotent. It may become idempotent in the future
// but currently you need to invoke it exactly once.
func (sess *Session) Close() (err error) {
	if sess != nil {
		err = sess.s.Close()
	}
	return
}

// Location contains the location of a probe.
type Location struct {
	ASN     string
	Country string
	IP      string
	Org     string
}

// Geolocate geolocates a probe. This function returns an error if passed
// a null context or when the sess receiver is null.
func (sess *Session) Geolocate(ctx *Context) (*Location, error) {
	if sess == nil || ctx == nil {
		return nil, ErrNullPointer
	}
	if err := sess.s.MaybeLookupLocationContext(ctx.ctx); err != nil {
		return nil, err
	}
	info := &Location{
		ASN:     sess.s.ProbeASNString(),
		Country: sess.s.ProbeCC(),
		IP:      sess.s.ProbeIP(),
		Org:     sess.s.ProbeNetworkName(),
	}
	return info, nil
}

// ProbeServicesClient is a client for OONI probe services. The probe services
// are a set of data centres hosted at different locations though which we could
// access all OONI APIs (bouncer, collector, orchestra, etc).
type ProbeServicesClient struct {
	clnt *probeservices.Client
	sess *Session
}

// NewProbeServicesClient creates a new ProbeServicesClient. This method will
// discover all available probe services and return the one that appears to have
// the best performance. If some probe services are down or blocked, they will
// be excluded. If all services are down or blocked, we will try to apply a bunch
// of circumvention tactics to work around the block.
func NewProbeServicesClient(ctx *Context, sess *Session) (*ProbeServicesClient, error) {
	if ctx == nil || sess == nil {
		return nil, ErrNullPointer
	}
	clnt, err := sess.s.NewProbeServicesClient(ctx.ctx)
	if err != nil {
		return nil, err
	}
	return &ProbeServicesClient{clnt: clnt, sess: sess}, nil
}

// Measurement is a OONI measurement. The current implementation is such that
// you cannot directly manipulate a measurement from Java/ObjC. Yet, you can
// create a new measurement from a serialized JSON and serialize a specific
// measurement to JSON. This allows you to resubmit a measurement.
type Measurement struct {
	m model.Measurement
}

// NewMeasurement loads a measurement from a serialized JSON string.
func NewMeasurement(serialized string) (*Measurement, error) {
	m := new(Measurement)
	if err := json.Unmarshal([]byte(serialized), &m.m); err != nil {
		return nil, err
	}
	return m, nil
}

// Marshal dumps a measurement to a JSON string.
func (m *Measurement) Marshal() (string, error) {
	b, err := json.Marshal(m.m)
	runtimex.PanicOnError(err, "json.Marshal should not fail here")
	return string(b), nil
}
