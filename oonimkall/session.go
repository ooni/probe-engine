package oonimkall

import (
	"context"
	"fmt"
	"math"
	"time"

	"github.com/ooni/probe-engine/model"
)

// SessionConfig contains configuration for a Session.
type SessionConfig struct {
	// AssetsDir is the mandatory directory where to store assets
	// required by a Session, e.g. MaxMind DB files.
	AssetsDir string

	// Logger is the optional logger that will receive all the
	// log messages generated by a Session. If this field is nil
	// then the session will not emit any log message.
	Logger Logger

	// SoftwareName is the mandatory name of the application
	// that is using the OONI Probe Engine.
	SoftwareName string

	// SoftwareVersion is the mandatory version of the application
	// that is using the OONI Probe Engine.
	SoftwareVersion string

	// StateDir is the mandatory directory where to store state
	// information required by a Session.
	StateDir string

	// TempDir is the mandatory directory where the Session shall
	// store temporary files. Among other tasks, Session.Close will
	// ensure that temporary files have been removed.
	TempDir string

	// Verbose is optional. If there is a non-null Logger and this
	// field is true, then the Logger will also receive Debug messages,
	// otherwise it will not receive such messages.
	Verbose bool
}

// Logger is the logger used by a Session. You should implement a class
// compatible with this interface in Java/ObjC and then save a reference
// to this instance in the SessionConfig object. All log messages that
// the Session will generate will be routed to this Logger.
type Logger interface {
	Debug(msg string)
	Info(msg string)
	Warn(msg string)
}

type loggerVerbose struct {
	Logger
}

func (slv loggerVerbose) Debugf(format string, v ...interface{}) {
	slv.Debug(fmt.Sprintf(format, v...))
}
func (slv loggerVerbose) Infof(format string, v ...interface{}) {
	slv.Info(fmt.Sprintf(format, v...))
}
func (slv loggerVerbose) Warnf(format string, v ...interface{}) {
	slv.Warn(fmt.Sprintf(format, v...))
}

type loggerNormal struct {
	Logger
}

func (sln loggerNormal) Debugf(format string, v ...interface{}) {
	// nothing
}
func (sln loggerNormal) Debug(msg string) {
	// nothing
}
func (sln loggerNormal) Infof(format string, v ...interface{}) {
	sln.Info(fmt.Sprintf(format, v...))
}
func (sln loggerNormal) Warnf(format string, v ...interface{}) {
	sln.Warn(fmt.Sprintf(format, v...))
}

type loggerQuiet struct{}

func (loggerQuiet) Debugf(format string, v ...interface{}) {
	// nothing
}
func (loggerQuiet) Debug(msg string) {
	// nothing
}
func (loggerQuiet) Infof(format string, v ...interface{}) {
	// nothing
}
func (loggerQuiet) Info(msg string) {
	// nothing
}
func (loggerQuiet) Warnf(format string, v ...interface{}) {
	// nothing
}
func (loggerQuiet) Warn(msg string) {
	// nothing
}

// NewLogger creates a new instance of model.Logger from the provided
// config. This factory function is not available to Java/ObjC because
// the returned type is not supported. This is intended: it does not
// make sense to use a model.Logger when not using Go.
func NewLogger(config *SessionConfig) model.Logger {
	if config == nil || config.Logger == nil {
		return loggerQuiet{}
	}
	if config.Verbose {
		return loggerVerbose{Logger: config.Logger}
	}
	return loggerNormal{Logger: config.Logger}
}

// The Context allows the programmer to interrupt long running operations
// and/or to add specific timeouts to such operations. Make sure you always
// call Close when you are done using a Context.
type Context struct {
	cancel  context.CancelFunc
	ctx     context.Context
	timeout int64
}

// NewContext creates a new Context.
func NewContext() *Context {
	ctx := new(Context)
	ctx.ctx, ctx.cancel = context.WithCancel(context.Background())
	return ctx
}

// MaxContextTimeout is the maximum timeout that you can set with
// the NewContextWithTimeout function. Any value greater than this
// value will be silently clamped down to such a value.
const MaxContextTimeout = int64(time.Duration(math.MaxInt64) / time.Second)

// NewContextWithTimeout creates a new Context where the operations using
// such a Context will fail after timeout seconds. If the timeout argument
// is zero or less, this constructor is equivalent to NewContext. Note that
// any value that is greater than MaxContextTimeout is clamped down to
// MaxContextTimeout to avoid overflow errors.
func NewContextWithTimeout(timeout int64) *Context {
	ctx := new(Context)
	if timeout > 0 {
		if timeout > MaxContextTimeout {
			timeout = MaxContextTimeout
		}
		ctx.ctx, ctx.cancel = context.WithTimeout(
			context.Background(), time.Duration(timeout)*time.Second,
		)
		ctx.timeout = timeout
	} else {
		ctx.ctx, ctx.cancel = context.WithCancel(context.Background())
	}
	return ctx
}

// Context returns the underlying context.Context. This method is not
// exported to Java/ObjC because the context.Context type is an interface
// containing some fields that cannot be represented in Java/ObjC.
//
// Because this method is not exported to Java/ObjC we will not bother
// with making sure that it behaves with a null pointer receiver.
func (ctx *Context) Context() context.Context {
	return ctx.ctx
}

// GetTimeout returns the timeout (in seconds) configured for the context. A
// negative or zero value implies there is no timeout.
func (ctx *Context) GetTimeout() (timeout int64) {
	if ctx != nil {
		timeout = ctx.timeout
	}
	return
}

// Cancel cancels any pending operation. This method is idempotent
// and only its first invocation has side effects. This method is
// thread safe; it might be called from any thread.
func (ctx *Context) Cancel() {
	if ctx != nil {
		ctx.cancel()
	}
}

// Close releases the resources allocated by the SessionContext. This
// method is idempotent; only its first invocation has side effects. It
// is also thread safe and might be called from any thread.
func (ctx *Context) Close() error {
	ctx.Cancel() // calling Cancel which handles nil gracefully
	return nil
}
